[commit 1 - desde las 11 am hasta las 9pm]

bueno para empezar, elegimos la tematica del proyecto en base a un calabozo, nuestra pirnicpal fuente de inspiracion fue Dark Souls 1, en donde el usuario comienza en un calabozo y le dan una llave, el usuario debera avanzar e interactuar un poco con el entorno par aencontrarse de primeras con un boss, dicho boss es imposible derrotarle al principio por lo que debes tomar una ruta alternativa, recoger recursos y volver a el y derrotarlo un poco mas fuerte para poder avanzar, cada habitacion por las que el usuario pasa, desde el inicio hasta el final pueden interpretarse como nodos, y gracias grafo de lista indirecta el usuario pueda moverse entre las habitaciones con total libertad, porque la idea es que de cada sala agote los "dialogos" o las acciones y el juego lo ira guiando de forma intuitiva. Al derrotar el boss el usuario podra seguir caminando y descubriendo zonas, que estan limitadas por el proyecto claro, pero lo deja abierto a que se pueda continuar en un futuro, decidimos colocarle "Perpetuals" porque la idea es que el usuario al terminar el juego se vuelva el nuevo boss del calabozo y asi al crear una nueva partida, el usuario debe derrotar al antiguo jugador que fue el mismo, tomando un poco de paralelismo con el juego en el que nos inspiramos que va por esos aires.

Bien, teniendo esa premisa nos pusimos manos a la obra

Creamos un proyecto java llamado "perpetual"

en el paquete perpetuals donde estara la main estatica, fluira el videojuego por consola donde al usuario se le narrara la historia con un algoritmo que permite mostrar el texto con un poco de delay.

El algoritmo:
public static void Narrar(String texto) {
    for (int i = 0; i < texto.length(); i++) {
        char c = texto.charAt(i);
        System.out.print(c);
        System.out.flush();

        try {
            if (c == '.' || c == ',' || c == '…') {
                Thread.sleep(200); // pausa larga en signos
            } else {
                Thread.sleep(10);  // pausa normal por letra
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    System.out.println();
}

Ejemplo del flujo del programa:

    public static void main(String[] args) {
        menu();
    }
    
    private static void menu(){
        Scanner scanner = new Scanner(System.in);
        System.out.println("PERPETUALS");
        System.out.println("1. Jugar");
        System.out.println("2. Salir");
        System.out.print("Seleccione una opcion: ");
        String opcion = scanner.nextLine();
        switch (opcion) {
            case "1":
                    intro();
                break;
            case "2":         
                    System.out.println("Chao");
                break;
            default:
                    System.out.println("elije bien");
                break;
        }
    }

Y en intro:

private static void intro() {
            Scanner scanner = new Scanner(System.in);
            User jugador = new User("Perpetuo");
            Narrar("La piedra está fría.\n" +
            "La humedad se filtra entre las grietas del suelo y el aire huele a óxido y encierro.\n" +
            "Una figura yace encorvada en la oscuridad: piel apagada, ojos hundidos, alma rota…\n\n" +

            "Es el Perpetuo.\n\n" +

etc.. etc..

        Narrar("\n\n¡Has obtenido: Llave de celda!\n");
        Narrar("[Llave de celda ha sido añadida a tu inventario]");
        jugador.agregarItem(new Item("Llave de celda", "llave"));
        System.out.println("¿Que deseas hacer?");
        System.out.println("1. Abrir celda");
        System.out.println("2. Ver inventario.");
        System.out.print("Selecciona una opción: ");
        opcion = scanner.nextLine();
        switch (opcion) {

Evidenciando asi que cada que el usuario opta por una opcion tendra consecuencias

Enconces teniendo claro como sera el flujo de la narracion y como el usuario jugara

en el paquete estructuras 

hicimos una estructura de datos, una lista, llama inventario y una clase item de la cual estara llena

package estructuras;

public class Inventario {

    private Nodo cabeza;

    // Clase interna Nodo
    private class Nodo {
        Item item;
        Nodo siguiente;

        Nodo(Item item) {
            this.item = item;
            this.siguiente = null;
        }
    }

    public void agregar(Item item) {
        Nodo nuevo = new Nodo(item);
        if (cabeza == null) {
            cabeza = nuevo;
        } else {
            Nodo actual = cabeza;
            while (actual.siguiente != null) {
                actual = actual.siguiente;
            }
            actual.siguiente = nuevo;
        }
    }

    public void mostrar() {
        Nodo actual = cabeza;
        System.out.println("\nInventario:\n");
        if (actual == null) {
            System.out.println("- (vacío)");
            return;
        }
        while (actual != null) {
            System.out.println("- " + actual.item);
            actual = actual.siguiente;
        }
    }
    
    public boolean contiene(String nombre) {
        Nodo actual = cabeza;
        while (actual != null) {
            if (actual.item.getNombre().equalsIgnoreCase(nombre)) {
                return true;
            }
            actual = actual.siguiente;
        }
        return false;
    }
}

package estructuras;

public class Item {
    private String nombre;
    private String tipo; 

    public Item(String nombre, String tipo) {
        this.nombre = nombre;
        this.tipo = tipo;
    }
    
        public String getNombre() {
        return nombre;
    }

    public String getTipo() {
        return tipo;
    }

    @Override
    public String toString() {
        return nombre + " [" + tipo + "]";
    }
}


hicimos la clase user que estara en su paquete user para que pudiese interactuar con dicho inventario teniendolo como atributo

package user;

import estructuras.Item;
import estructuras.Inventario;

public class User {

    private String nombre;
    private Inventario inventario;

    public User(String nombre) {
        this.nombre = nombre;
        this.inventario = new Inventario();
    }

Y por ultimo un paquete mapa, donde estara: Grafo, List y UndirectedGraphList que son la base para montar el grafo, como se explico en clases, la razon por la que usamos una indirecta es porque queremos que el usuario pueda ir desde un nodo a otro, que en este caso seran salas, que tenga libertad de moverse.

dentro del paque mapa, estara una clase llamada mapa donde se creara la estructura del mapa (dicho mapa es un poco mas amplio pero por ahora esta bien asi para ir probando)

package perpetuals.mapa;

import mapa.UndirectedGraphList;
import mapa.List;


public class Mapa {

    private UndirectedGraphList grafo;

    public Mapa() {
        grafo = new UndirectedGraphList(6);
        grafo.addEdge(1, 2);
        grafo.addEdge(2, 3);
        grafo.addEdge(2, 4);
        grafo.addEdge(2, 5);
        grafo.addEdge(3, 4);
    }

    public List<Integer> getSalasVecinas(int salaActual) {
        return grafo.getAdyacentes(salaActual);
    }

    public boolean puedeMoverse(int desde, int hacia) {
        List<Integer> vecinos = grafo.getAdyacentes(desde);
        for (int i = 0; i < vecinos.size(); i++) {
            if (vecinos.get(i) == hacia) {
                return true;
            }
        }
        return false;
    }

    public void mostrarMapa() {
        grafo.printGraph();
    }
}

[commit 2 - desde las 5 am hasta las 8pm]

Ok, ayer al poner la clase mapa y declarar el mapa de grafos

        grafo = new UndirectedGraphList(6);
        grafo.addEdge(1, 2);
        grafo.addEdge(2, 3);
        grafo.addEdge(2, 4);
        grafo.addEdge(2, 5);
        grafo.addEdge(3, 4);

hoy lo montamos en la main

import mapa.Mapa;

    public static void main(String[] args) {
        Mapa mapa = new Mapa();
        menu(mapa);
    }

y declaramos globalmente al scanner

private static Scanner scanner = new Scanner(System.in);

con el mapa declarado ahora queremos que este mapa pase tanto por menu como intro asi que se lo pasamos como paramentro

private static void menu(Mapa mapa)

luego a intro 

private static void intro(Mapa mapa)

asi en la main

    public static void main(String[] args) {
        Mapa mapa = new Mapa();
        menu(mapa);
    }

asi el usuario aparte de tener su inventario tambien tendra su mapa asignado

para luego llegar al ultimo metodo recursivo, pero mas que recursivo simplemente es un bucle, la premisa es que cada que el usuario se situe en un nodo, pueda elegir a donde ir en base a la lista de abyacencia, entonces..

private static void explorar(Mapa mapa, User jugador) {
        mapa.mostrarMapa(); // mostrar el grafo, la lista de adyacencia siempre la primera vez (en resources igual hay una foto del mapa)

        while (true) {
            int actual = jugador.getSalaActual(); // en actual guardamos la sala en la que esta el usuario la primera vez, (en 1 en la celda)
            mapa.List<Integer> vecinos = mapa.getSalasVecinas(actual); //lista de sala vecinas en base a la de la actual del jugador

            System.out.println("\n-------------------------------------");
            System.out.println("Estás en la sala " + actual + ". ¿Qué deseas hacer?");
            for (int i = 0; i < vecinos.size(); i++) {
                System.out.println((i + 1) + ". Ir a sala " + vecinos.get(i)); // recursovamente imprime las salas vecinas a la qu esta situada el usuario
            }
            System.out.println((vecinos.size() + 1) + ". Ver inventario");

            System.out.print("Elige una opción: ");
            String entrada = scanner.nextLine();
    }
}

Asi quedo nuestro metodo, en la consola dependiendo de donde nos coloquemos nos mostraba las salas abyacentes en funcion a donde estaba parado el usuario

PERO no sabiamos como plantear el movimiento entre salas asi que le pedimos a la IA algo tipo

"Por favor necesitamos que el usuario pueda moverse entre las abyacentes y nos complemento con 

try {
                int eleccion = Integer.parseInt(entrada);
                if (eleccion >= 1 && eleccion <= vecinos.size()) {
                    int destino = vecinos.get(eleccion - 1);
                    jugador.setSalaActual(destino);
                    Narrar("Avanzas hacia la sala " + destino + "...");
                    eventoSala(destino, jugador);
                } else if (eleccion == vecinos.size() + 1) {
                    jugador.mostrarInventario();
                } else {
                    System.out.println("Opción inválida.");
                }
            } catch (NumberFormatException e) {
                System.out.println("Ingresa un número válido.");
            }

Y abajo de de Avanzas hacia la sala...
debjao hay un evento sala, ese metodo eventoSala tomara como parametro al jugador y al a sala donde se movera, y cada sala sala tendra su evento, como tener llaves o pistas

pero por ahora esta vacio pero funciona todo chevere

private static void eventoSala(int sala, User jugador) {
        switch (sala) {
            case 2:
                Narrar("ejemplo");
                break;
            case 3:
                Narrar("");
                break;
            case 4:
                Narrar("");
                break;
            case 5:
                Narrar("");
                break;
            default:
                break;
        }
    }

Aparte de este uso de la IA, lo demas ha sido corrigiendo errores entre paquetes pero por ahora esta funcional el movimiento con sus eventos

[Commit 3 - 12pm a 5 pm]

Bien ya con las bases hechas lo primero que hicimos fue aumentar el tamaño del mapa, lo colocamos asi

    public Mapa() {
        grafo = new UndirectedGraphList(9);
        grafo.addEdge(1, 2);
        grafo.addEdge(2, 3);
        grafo.addEdge(2, 4);
        grafo.addEdge(2, 5);
        grafo.addEdge(3, 4);
        grafo.addEdge(5, 6);
        grafo.addEdge(6, 7);
        grafo.addEdge(6, 8);
    }
En la sala 3 colocamos una llave y en la sala 4 colocamos un cofre, el cual contiene el talisman para avanzar a la sala 5

definimos unas variables globales y en eventoSala:

case 3:
                if (!llaveCofreObtenida) {
                    Narrar("Encuentras algo en una esquina polvorienta...\n¡Es una Llave de cofre!");
                    jugador.agregarItem(new Item("Llave de cofre", "llave"));
                    llaveCofreObtenida = true;
                }
                break;

case 4:
                if (!cofreAbierto) {
                    Narrar("Hay un cofre antiguo frente a ti...");
                    if (jugador.tieneItem("Llave de cofre")) {
                        Narrar("Usas la Llave de cofre y el cofre se abre lentamente...\n¡Obtienes un Talismán de protección!");
                        jugador.agregarItem(new Item("Talismán", "artefacto"));
                        cofreAbierto = true;
                    } else {
                        Narrar("El cofre está cerrado. Parece que necesita una llave especial...");
                    }
                }
                break;

Asi el usuario al pasar por sala 3 y sala 4 interactue en base a lo que tenga en su inventario y asi si vuelven a pasar, no se repiten los dialogos, luego

case 5:
                if (!jugador.tieneItem("Talismán")) {
                    Narrar("Una barrera mágica bloquea el paso.\nSin un talismán protector no puedes avanzar más allá...");
                    jugador.setSalaActual(2); // Reversa el movimiento
                } else {
                    Narrar("El talismán vibra al acercarte...\nLa barrera mágica desaparece. Puedes avanzar.");
                }
                break;

el jugador podra pasar del 2 al 5, porque el talisman que hay en el cofre le permite avanzar.

una vez en la sala 6, el usuario tendra 2 caminos, el 8 (bloqueado porque es el final) y en al 7, en el 7 hay un cofre y una llave, PERO una ladron la toma y sale corriendo hacia la sala 1 donde murio, porque atraveso la barrera del 5 a 2 sin un talisman quedando su cuerpo en la sala 1, donde empezamos, el jugador trenda que ir desde 

la 7 hasta la 1, tomara la llave.

para volver al cofre de la 7 y al lootearlo obtiene una reliquia, reliquia la cual le permite ir del 7 al 8.

dichos eventos estan perfectamente modulados

    private static void eventoSala(int sala, User jugador) {
        switch (sala) {
            case 1:
                if (jugador.isEventoLadronActivado() && !jugador.tieneItem("Llave secreta del ladrón")) {
                    Narrar("Encuentras un cuerpo sin vida apoyado contra la pared... Es el ladrón.");
                    Narrar("Tiene marcas de quemaduras arcanas y su cuerpo está retorcido en dolor.");
                    Narrar("Entre sus dedos rígidos, aún aprieta una pequeña llave con inscripciones extrañas.");
                    Narrar("Obtienes: Llave secreta del ladrón.");
                    jugador.agregarItem(new Item("Llave secreta del ladrón", "llave"));
                }
            break;

            case 3:
                if (!llaveCofreObtenida) {
                    Narrar("Encuentras algo en una esquina polvorienta...\n¡Es una Llave de cofre!");
                    jugador.agregarItem(new Item("Llave de cofre", "llave"));
                    llaveCofreObtenida = true;
                }
                break;

            case 4:
                if (!cofreAbierto) {
                    Narrar("Hay un cofre antiguo frente a ti...");
                    if (jugador.tieneItem("Llave de cofre")) {
                        Narrar("Usas la Llave de cofre y el cofre se abre lentamente...\n¡Obtienes un Talismán de protección!");
                        jugador.agregarItem(new Item("Talismán", "artefacto"));
                        cofreAbierto = true;
                    } else {
                        Narrar("El cofre está cerrado. Parece que necesita una llave especial...");
                    }
                }
                break;

            case 5:
                if (!jugador.tieneItem("Talismán")) {
                    Narrar("Una barrera mágica bloquea el paso.\nSin un talismán protector no puedes avanzar más allá...");
                    jugador.setSalaActual(2); // Reversa el movimiento
                } else {
                    Narrar("El talismán vibra al acercarte...\nLa barrera mágica desaparece. Puedes avanzar.");
                }
                break;

            case 6:
                Narrar("Encuentras dos caminos... hacia adelante... hay una puerta dentro de lo que parece ser un manantial (sala 9), se necesita un talismán, por otro lado una cueva con niebla (sala 7)");
                break;

        case 7:
            if (!jugador.isEventoLadronActivado()) {
                jugador.activarEventoLadron();
                Narrar("Entras a una sala oscura... entre la niebla densa ves lo que parece ser... ¡Un cofre! y una llave al lado.");
                Narrar("Escuchas pasos... un ladrón ha pasado corriendo y se lleva la llave.");
                Narrar("—¡Tonto! ¡Este tesoro es mío, ja ja ja!");
                Narrar("[El ladrón ha salido corriendo y ha traspasado una puerta que necesita un talismán.]");
                Narrar("[El ladrón ha sufrido severos daños por hacer eso... No debe de poder avanzar demasiado con esas heridas.]");
            } else if (jugador.tieneItem("Llave secreta del ladrón") && !jugador.tieneItem("Talisman de agua")) {
                Narrar("Usas la llave secreta del ladrón para abrir el cofre.");
                Narrar("Dentro encuentras un talismán con un brillo extraño...");
                jugador.agregarItem(new Item("Talisman de agua", "reliquia"));
            } else if (!jugador.tieneItem("Llave secreta del ladrón") && !jugador.tieneItem("Talisman de agua")) {
                Narrar("El cofre permanece cerrado. La llave fue robada por el ladrón.");
                Narrar("Ese desquiciado entró en un pozo sin salida al cruzar la barrera mágica sin protección...");
                Narrar("No debe de estar muy lejos.");
            }
            break;
            case 8:
                if (!jugador.tieneItem("Talisman de agua")) {
                    Narrar("Una barrera de agua bloquea el camino.\nCon un talismán de agua quizá me dejaría avanzar más allá...");
                    jugador.setSalaActual(6); 
                } else {
                    Narrar("La reliquia comienza a brillar intensamente al acercarte...");
                    Narrar("Una barrera de agua se forma a tu alrededor, protegiéndote del poder que emana del portal.");
                    Narrar("Das un paso... luego otro... y atraviesas la barrera sin resistencia.");
                    Narrar("Del otro lado, una luz cálida golpea tu rostro...");
                    Narrar("¡Es la luz del sol!");

                    Narrar("Sales del calabozo por una enorme abertura en la roca...\nEl aire fresco llena tus pulmones por primera vez en lo que parece una eternidad.");
                    Narrar("Desde el cielo desciende un majestuoso cuervo negro, de ojos antiguos y alas colosales.");
                    Narrar("—Perpetuo... —dice con voz grave y solemne—\nTu camino no ha acabado aquí.");
                    Narrar("Te recogeré de esta prisión olvidada y te llevaré a un nuevo reino, donde el verdadero propósito de tu existencia será revelado...");
                    Narrar("Eres uno entre muchos, un elegido entre los condenados.\nTe esperan más secretos, más acertijos, más pruebas.");

                    Narrar("El cuervo te alza con sus garras, y mientras te elevas, el calabozo queda atrás...");
                    Narrar("Tu historia apenas comienza...");

                    System.out.println("\n--- FIN DEL JUEGO (continuara...) ---");
                    System.exit(0);
                }
                break;
        }

toda la escena del ladron es un evento, evento el cual la idea es que suceda SOLO cuando el usuario entra por primera vez a la sala

entonces a user.java le colocamos


    public boolean isEventoLadronActivado() {
        return eventoLadronActivado;
    }

    public void activarEventoLadron() {
        this.eventoLadronActivado = true;
    }

asi permitiendo que no se repita el evento una y otra vez y podemos usar esa variable para 

case 7:
            if (!jugador.isEventoLadronActivado()) {
                jugador.activarEventoLadron();
                Narrar("Entras a una sala oscura... entre la niebla densa ves lo que parece ser... ¡Un cofre! y una llave al lado.");
                Narrar("Escuchas pasos... un ladrón ha pasado corriendo y se lleva la llave.");
                Narrar("—¡Tonto! ¡Este tesoro es mío, ja ja ja!");
                Narrar("[El ladrón ha salido corriendo y ha traspasado una puerta que necesita un talismán.]");
                Narrar("[El ladrón ha sufrido severos daños por hacer eso... No debe de poder avanzar demasiado con esas heridas.]");
            } else if (jugador.tieneItem("Llave secreta del ladrón") && !jugador.tieneItem("Talisman de agua")) {
                Narrar("Usas la llave secreta del ladrón para abrir el cofre.");
                Narrar("Dentro encuentras un talismán con un brillo extraño...");
                jugador.agregarItem(new Item("Talisman de agua", "reliquia"));
            } else if (!jugador.tieneItem("Llave secreta del ladrón") && !jugador.tieneItem("Talisman de agua")) {
                Narrar("El cofre permanece cerrado. La llave fue robada por el ladrón.");
                Narrar("Ese desquiciado entró en un pozo sin salida al cruzar la barrera mágica sin protección...");
                Narrar("No debe de estar muy lejos.");
            }

hacer un filtro entre eventos 

EASTER EGG O AYUDA: si sales a la sala 6 y vuelves a entrar: el perpetuo dira que el ladron le paso algo por cruzar la barrera magica sin proteccion dando a entender que seguro debe de estar por las zonas iniciales

por ultimo hicimos que el pajaro nos dijera mediante dfs las salas que estan en este mapa, aunque desordenadas, sirve de orientacion

            User jugador = new User("Perpetuo");
            
            Narrar("Una sombra cruza el cielo...");

            Narrar("El cuervo extiende sus alas y sobrevuela las ruinas del calabozo...");
            mapa.getGrafo().dfs(8);  


Tambien se añadio un paquete Ayuda con un mapa.png que sirva como orientacion
